#!/bin/sh

set -e

USAGE='Usage: git cococo [options] [--] <command> [args...]

Example:

    $ git cococo sed -e s/foo/bar/g *.txt
'

echo_n() {
  printf -- '%s' "$1"
}

uncommitted_changes_are_exists() {
  test x != "x$(git status --short)"
}

escape_quote_argument() {
  echo_n "$1" | sed -e "s/'/'\\\\''/g"
}

create_commit_message() {
  echo_n 'run: git cococo'
  for arg in "$@"
  do
    need_quote=
    expr "$arg" : '[ \$\"'\'']' > /dev/null && need_quote=1

    echo_n ' '
    test -n "$need_quote" && echo_n "'"
    escape_quote_argument "$arg"
    test -n "$need_quote" && echo_n "'"
  done
}

auto_stash=
while :
do
  case "$1" in
    --auto-stash)
      auto_stash=1
      ;;
    -h|--help)
      echo_n "$USAGE"
      exit
      ;;
    --)
      shift
      break
      ;;
    '')
      echo_n "$USAGE" 1>&2
      exit 1
      ;;
    *)
      break
      ;;
  esac
  shift
done

stashed=
if uncommitted_changes_are_exists
then
  if test -z "$auto_stash"
  then
    cat <<EOF
Detects following uncommitted changes:

`git status --short | sed -e 's|^|  |'`

Run "git stash" and retry "git cococo":

  $ git stash --include-untracked &&
    git cococo "$@" &&
    git stash pop

Or, use "--auto-stash" option:

  $ git cococo --auto-stash "$@"
EOF
    exit 1
  fi

  git stash --quiet --include-untracked
  stashed=1
fi

"$@"
if uncommitted_changes_are_exists
then
  git add --all
  create_commit_message "$@" | git commit --quiet --file=-
else
  echo No changes are detected.
fi

if test x1 = "x$stashed"
then
  # If only untracked files, always output "Already up to date!".
  #
  # https://github.com/git/git/blob/v2.15.0/merge-recursive.c#L1954
  git stash pop --quiet | sed -e '/^Already up to date!$/ d'
fi
